/**
 * Chat Service - API-based Chat Management
 * 
 * MULTI-USER CHAT SYSTEM:
 * - Uses API endpoints instead of direct Firestore access
 * - Prevents Firestore permission errors
 * - Backend handles authorization
 * - Polling for real-time-like updates
 */

import api from '../apiServer';

export interface Message {
  id: string;
  chatRoomId: string;
  senderId: string;      // MULTI-USER: Who sent the message
  receiverId: string;    // MULTI-USER: Who receives the message
  text: string;
  timestamp: string;
  read?: boolean;
}

export interface ChatRoom {
  id: string;
  participants: string[];        // MULTI-USER: Array of user IDs
  participantNames: string[];   // Names corresponding to participants
  productId: string;
  productTitle: string;
  productImage?: string;
  createdAt: string;
  updatedAt: string;
  lastMessage: string;
  lastMessageSenderId: string | null;
  otherParticipantId?: string;  // Computed: The other user in the chat
  otherParticipantName?: string; // Computed: The other user's name
  // Legacy fields for backward compatibility
  sellerId?: string;
  buyerId?: string;
  sellerName?: string;
  buyerName?: string;
  farmName?: string;
  postId?: string;
}

/**
 * Generate unique chat room ID from two user IDs and product ID
 * MULTI-USER: Creates consistent room ID regardless of who initiates
 * Uses SHA-256 hash to ensure ID is under 1500 bytes (Firestore limit)
 * NOTE: This matches the backend implementation in chatController.js
 * 
 * IMPORTANT: In production, chatRoomId is generated by backend API.
 * This function is mainly for reference/testing purposes.
 * 
 * @param userId1 - First user ID
 * @param userId2 - Second user ID
 * @param productId - Product ID
 * @returns Promise with unique chat room ID (hashed, 32 characters)
 */
export const generateChatRoomId = async (
  userId1: string, 
  userId2: string, 
  productId: string
): Promise<string> => {
  // Sort user IDs alphabetically to ensure consistency
  const sortedIds = [userId1, userId2].sort();
  
  // Create a unique string from participants and product
  const uniqueString = `${sortedIds[0]}_${sortedIds[1]}_${productId}`;
  
  // Use Web Crypto API to create SHA-256 hash (matches backend)
  const encoder = new TextEncoder();
  const data = encoder.encode(uniqueString);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  // Use first 32 characters (matches backend)
  return hashHex.substring(0, 32);
};

/**
 * Get chat rooms for a user (via API)
 * MULTI-USER: Only returns chat rooms where user is a participant
 * 
 * @returns Promise with chat rooms array
 */
export const getChatRooms = async (): Promise<ChatRoom[]> => {
  try {
    const response = await api.get('/chat');
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching chat rooms:', error);
    return [];
  }
};

/**
 * Get messages for a chat room (via API)
 * MULTI-USER: Only participants can access messages
 * 
 * @param chatRoomId - Chat room ID
 * @returns Promise with messages array
 */
export const getMessages = async (chatRoomId: string): Promise<Message[]> => {
  try {
    const response = await api.get(`/chat/${chatRoomId}/messages`);
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching messages:', error);
    return [];
  }
};

/**
 * Send a message to a chat room (via API)
 * MULTI-USER: Message includes senderId and receiverId (handled by backend)
 * 
 * @param chatRoomId - Chat room ID
 * @param text - Message text
 * @returns Promise with message data
 */
export const sendMessage = async (
  chatRoomId: string,
  text: string
): Promise<Message> => {
  try {
    const response = await api.post(`/chat/${chatRoomId}/messages`, { text });
    return response.data.data;
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
};

/**
 * Poll chat rooms for updates (simulates real-time)
 * MULTI-USER: Polls API endpoint periodically
 * 
 * @param callback - Function to call when chat rooms change
 * @param interval - Polling interval in milliseconds (default: 3000ms)
 * @returns Function to stop polling
 */
export const pollChatRooms = (
  callback: (chatRooms: ChatRoom[]) => void,
  interval: number = 3000
): (() => void) => {
  let isPolling = true;

  const poll = async () => {
    if (!isPolling) return;
    
    try {
      const rooms = await getChatRooms();
      callback(rooms);
    } catch (error) {
      console.error('Error polling chat rooms:', error);
    }

    if (isPolling) {
      setTimeout(poll, interval);
    }
  };

  // Start polling immediately
  poll();

  // Return stop function
  return () => {
    isPolling = false;
  };
};

/**
 * Poll messages for updates (simulates real-time)
 * MULTI-USER: Polls API endpoint periodically
 * 
 * @param chatRoomId - Chat room ID
 * @param callback - Function to call when messages change
 * @param interval - Polling interval in milliseconds (default: 2000ms)
 * @returns Function to stop polling
 */
export const pollMessages = (
  chatRoomId: string,
  callback: (messages: Message[]) => void,
  interval: number = 2000
): (() => void) => {
  if (!chatRoomId) {
    return () => {};
  }

  let isPolling = true;

  const poll = async () => {
    if (!isPolling) return;
    
    try {
      const messages = await getMessages(chatRoomId);
      callback(messages);
    } catch (error) {
      console.error('Error polling messages:', error);
    }

    if (isPolling) {
      setTimeout(poll, interval);
    }
  };

  // Start polling immediately
  poll();

  // Return stop function
  return () => {
    isPolling = false;
  };
};
